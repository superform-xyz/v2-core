// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.28;

// external
import { ERC7579HookBase } from "modulekit/Modules.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// Superform
import { SuperRegistryImplementer } from "../utils/SuperRegistryImplementer.sol";

import { ISuperExecutor } from "../interfaces/ISuperExecutor.sol";

import { console2 } from "forge-std/console2.sol";

contract LockFundsAccountHook is ERC7579HookBase, SuperRegistryImplementer {
    /*//////////////////////////////////////////////////////////////
                                 STORAGE
    //////////////////////////////////////////////////////////////*/
    mapping(address account => mapping(address asset => uint256 lockedAmount)) private lockedAmounts; 
      
    uint256 public transient balance;

    mapping(address => bool) internal _initialized;
    address constant ENTRYPOINT_0_7 = 0x0000000071727De22E5E9d8BAf0edAc6f37da032;

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/
    error NOT_ENTRYPOINT();
    error NOT_AUTHORIZED();
    error NOT_INITIALIZED();
    error NOT_IMPLEMENTED();
    error ALREADY_INITIALIZED();
    error NOT_ENOUGH_LOCKED_AMOUNT();
    error USED_MORE_FUNDS_THAN_ALLOWED();

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/
    event LockFunds(address indexed account, address indexed asset, uint256 amount);
    event UnlockFunds(address indexed account, address indexed asset, uint256 amount);

    constructor(address registry_) SuperRegistryImplementer(registry_) { }

    modifier onlyInitialized(address account) {
        if (!_initialized[account]) revert NOT_INITIALIZED();
        _;
    }

    modifier onlyExecutor() {
        if (_getAddress(superRegistry.SUPER_EXECUTOR_ID()) != msg.sender) revert NOT_AUTHORIZED();
        _;
    }

    /// @notice Check if the account is initialized
    /// @param account The account to check
    function isInitialized(address account) external view returns (bool) {
        return _initialized[account];
    }

    /// @notice Get the name of the module
    function name() external pure returns (string memory) {
        return "LockFundsAccountHook";
    }

    /// @notice Get the version of the module`1
    function version() external pure returns (string memory) {
        return "0.0.1";
    }

    /// @notice Check if the module is of a given type
    /// @param typeID The type to check
    function isModuleType(uint256 typeID) external pure override returns (bool) {
        return typeID == TYPE_HOOK;
    }

    /*//////////////////////////////////////////////////////////////////////////
                                     EXTERNAL METHODS
    //////////////////////////////////////////////////////////////////////////*/
    /// @notice Initialize the module with the given data
    function onInstall(bytes calldata) external override {
        if (_initialized[msg.sender]) revert ALREADY_INITIALIZED();
        _initialized[msg.sender] = true;
    }

    /// @notice Uninstall the module
    /// @dev Not allowed to uninstall the module
    function onUninstall(bytes calldata) external view override {
        if (!_initialized[msg.sender]) revert NOT_INITIALIZED();
        revert NOT_IMPLEMENTED();
    }

    /// @notice Lock the given amount of funds for the given account
    /// @dev Only the executor can lock funds for an account which has this module installed
    /// @param account The account to lock the funds for
    /// @param asset The asset to lock the funds for
    /// @param amount The amount of funds to lock
    function lock(address account, address asset, uint256 amount) external onlyExecutor onlyInitialized(account) {
        lockedAmounts[account][asset] += amount;
        emit LockFunds(account, asset, amount);
    }

    /// @notice Unlock the given amount of funds for the given account
    /// @dev Only the executor can unlock funds for an account which has this module installed
    /// @param account The account to unlock the funds for
    /// @param asset The asset to unlock the funds for
    /// @param amount The amount of funds to unlock
    function unlock(address account, address asset, uint256 amount) external onlyExecutor onlyInitialized(account) {
        if (lockedAmounts[account][asset] < amount) revert NOT_ENOUGH_LOCKED_AMOUNT();
        lockedAmounts[account][asset] -= amount;
        emit UnlockFunds(account, asset, amount);
    }

    /*//////////////////////////////////////////////////////////////////////////
                                     INTERNAL METHODS
    //////////////////////////////////////////////////////////////////////////*/
    function _preCheck(
        address account,
        address msgSender,
        uint256, //msgValue
        bytes calldata msgData
    )
        internal
        override
        returns (bytes memory hookData)
    {
        console2.log("----A");
        _checkSender(msgSender);
        console2.log("----B");
        bytes4 selector = bytes4(msgData[:4]);
        console2.log("----C");
        console2.logBytes4(selector);
        if (selector == IERC20.transfer.selector) {
            console2.log("----transfer");
        } else if (selector == IERC20.transferFrom.selector) {
            console2.log("----transferFrom");
        } else if (selector == ISuperExecutor.execute.selector) {
            console2.log("----execute");
        }
        console2.log("----D");
        balance = IERC20(address(0)).balanceOf(account);
        return abi.encode(address(0));
    }

    function _postCheck(
        address account,
        bytes calldata hookData
    )
        internal
        override
    {
        uint256 _balanceBefore = balance;
        address asset = abi.decode(hookData, (address));
        balance = IERC20(asset).balanceOf(account);

        if (balance < _balanceBefore) {
            uint256 usedAmount = _balanceBefore - balance;
            if (lockedAmounts[account][address(0)] < usedAmount) revert USED_MORE_FUNDS_THAN_ALLOWED();
        }
    }

    /*//////////////////////////////////////////////////////////////////////////
                                     PRIVATE METHODS
    //////////////////////////////////////////////////////////////////////////*/
    function _getAddress(bytes32 id_) internal view returns (address) {
        return superRegistry.getAddress(id_);
    }

    function _checkSender(address msgSender) internal pure {
        if (msgSender != ENTRYPOINT_0_7) revert NOT_ENTRYPOINT();
    }
}