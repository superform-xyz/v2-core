// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.28;

import { ISuperLedger } from "../interfaces/accounting/ISuperLedger.sol";
import { ISuperRegistry } from "../interfaces/ISuperRegistry.sol";
import { ISuperRbac } from "../interfaces/ISuperRbac.sol";

import "./BaseLedger.sol";


/// @notice Default ISuperLedger implementation
contract Vault7540Ledger is BaseLedger, ISuperLedger {
    /*//////////////////////////////////////////////////////////////
                            STORAGE
    //////////////////////////////////////////////////////////////*/
    struct Ledger7540Entry {
        uint256 amountSharesAvailableToConsume;
        uint256 price;
        uint256 requestId;
    }

    struct Ledger7540 {
        Ledger7540Entry[] entries;
        uint256 unconsumedEntries;
    }

    /// @notice Tracks user's ledger entries for each yield source address
    mapping(address user => mapping(address yieldSource => Ledger7540 ledger)) internal userLedger7540;

    constructor(address registry_) BaseLedger(registry_) { }

    modifier onlyLedgerManager() {
        ISuperRegistry superRegistry = superLedgerConfiguration.superRegistry();
        ISuperRbac rbac = ISuperRbac(superRegistry.getAddress(keccak256("SUPER_RBAC_ID")));
        if (!rbac.hasRole(keccak256("LEDGER_MANAGER"), msg.sender)) revert NOT_AUTHORIZED();
        _;
    }


    /*//////////////////////////////////////////////////////////////
                            OWNER FUNCTIONS
    //////////////////////////////////////////////////////////////*/
    /// @notice Updates an user entry at a specific index
    /// @param user the account address
    /// @param yieldSource the yieldSource address
    /// @param index the ledger entry item array index
    /// @param price the new pps
    // TODO: should we fetch `price` from the oracle at this point?
    //      a malicious `onlyLedgerManager` could use a fake price
    function updateUserEntryByIndex(address user, address yieldSource, uint256 index, uint256 price) external onlyLedgerManager {
        Ledger7540 storage ledger = userLedger7540[user][yieldSource];
        ledger.entries[index].price = price;
    }

    /// @notice Updates an user entry for a request id
    /// @param user the account address
    /// @param yieldSource the yieldSource address
    /// @param requestId the requestId to update the price for
    /// @param price the new pps
    // TODO: should we fetch `price` from the oracle at this point?
    //      a malicious `onlyLedgerManager` could use a fake price
    function udpateUserEntryByRequestId(address user, address yieldSource, uint256 requestId, uint256 price) external onlyLedgerManager {
        Ledger7540 storage ledger = userLedger7540[user][yieldSource];

        uint256 len = ledger.entries.length;
        for (uint256 i; i < len;) {
            if (requestId == ledger.entries[i].requestId) {
                ledger.entries[i].price = price;
            }
            unchecked { ++i; }
        }
    }

    /*//////////////////////////////////////////////////////////////
                            VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/
    /// @inheritdoc ISuperLedger
    function getLedger(
        address user,
        address yieldSource
    )
        external
        view
        returns (LedgerEntry[] memory entries, uint256 unconsumedEntries)
    {
        Ledger7540 memory ledger = userLedger7540[user][yieldSource];
        uint256 len = ledger.entries.length;
        for (uint256 i; i
        return LedgerEntry(ledger.entries, ledger.unconsumedEntries);
    }

    function get7540Ledger(
        address user,
        address yieldSource
    )
        external
        view
        returns (Ledger7540Entry[] memory entries, uint256 unconsumedEntries)
    {
        Ledger7540 memory ledger = userLedger7540[user][yieldSource];
        return (ledger.entries, ledger.unconsumedEntries);
    }

    /*//////////////////////////////////////////////////////////////
                            EXTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/
    /// @inheritdoc ISuperLedger
    function updateAccounting(
        address user,
        address yieldSource,
        bytes4 yieldSourceOracleId,
        bool isInflow,
        uint256 amountSharesOrAssets,
        uint256 usedShares
    )
        external
        onlyExecutor
        returns (uint256 feeAmount)
    {
        return _updateAccounting(user, yieldSource, yieldSourceOracleId, isInflow, amountSharesOrAssets, usedShares);
    }

    /*//////////////////////////////////////////////////////////////
                            PRIVATE FUNCTIONS
    //////////////////////////////////////////////////////////////*/
    function _updateAccounting(
        address user,
        address yieldSource,
        bytes4 yieldSourceOracleId,
        bool isInflow,
        uint256 amountSharesOrAssets,
        uint256 usedShares
    )
        internal
        virtual
        returns (uint256 feeAmount)
    {
        ISuperLedgerConfiguration.YieldSourceOracleConfig memory config = superLedgerConfiguration.getYieldSourceOracleConfig(yieldSourceOracleId);

        if (config.manager == address(0)) revert MANAGER_NOT_SET();

        if (isInflow) {
            // Get price from oracle
            uint256 pps = IYieldSourceOracle(config.yieldSourceOracle).getPricePerShare(yieldSource);
            if (pps == 0) revert INVALID_PRICE();

            // Always inscribe in the ledger, even if feePercent is set to 0
            userLedger7540[user][yieldSource].entries.push(
                Ledger7540Entry({ amountSharesAvailableToConsume: amountSharesOrAssets, price: pps, requestId: 0 })
            );
            emit AccountingInflow(user, config.yieldSourceOracle, yieldSource, amountSharesOrAssets, pps);
            return 0;
        } else {
            // Only process outflow if feePercent is not set to 0
            if (config.feePercent != 0) {
                feeAmount = _processOutflow(user, yieldSource, amountSharesOrAssets, usedShares, config);

                emit AccountingOutflow(user, config.yieldSourceOracle, yieldSource, amountSharesOrAssets, feeAmount);
                return feeAmount;
            } else {
                emit AccountingOutflowSkipped(user, yieldSource, yieldSourceOracleId, amountSharesOrAssets);
                return 0;
            }
        }
    }

    function _processOutflow(
        address user,
        address yieldSource,
        uint256 amountAssets,
        uint256 usedShares,
        ISuperLedgerConfiguration.YieldSourceOracleConfig memory config
    )
        internal
        virtual
        returns (uint256 feeAmount)
    {
        uint256 remainingShares = usedShares;
        uint256 costBasis;

        Ledger7540 storage ledger = userLedger7540[user][yieldSource];
        uint256 len = ledger.entries.length;
        if (len == 0) return 0;

        uint256 currentIndex = userLedger7540[user][yieldSource].unconsumedEntries;

        while (remainingShares > 0) {
            if (currentIndex >= len) revert INSUFFICIENT_SHARES();

            Ledger7540Entry storage entry = ledger.entries[currentIndex];
            uint256 availableShares = entry.amountSharesAvailableToConsume;

            // if no shares available on current entry, move to the next
            if (availableShares == 0) {
                unchecked {
                    ++currentIndex;
                }
                continue;
            }

            uint256 decimals = IYieldSourceOracle(config.yieldSourceOracle).decimals(yieldSource);

            // remove from current entry
            uint256 sharesConsumed = availableShares > remainingShares ? remainingShares : availableShares;
            entry.amountSharesAvailableToConsume -= sharesConsumed;
            remainingShares -= sharesConsumed;

            costBasis += sharesConsumed * entry.price / (10 ** decimals);

            if (sharesConsumed == availableShares) {
                unchecked {
                    ++currentIndex;
                }
            }
        }

        userLedger7540[user][yieldSource].unconsumedEntries = currentIndex;

        uint256 profit = amountAssets > costBasis ? amountAssets - costBasis : 0;

        if (profit > 0) {
            if (config.feePercent == 0) revert FEE_NOT_SET();

            // Calculate fee in assets but don't transfer - let the executor handle it
            feeAmount = (profit * config.feePercent) / 10_000;
        }
    }
}