#!/opt/homebrew/bin/bash

# Ensure this script is run with bash, not sh
if [ -z "${BASH_VERSION}" ]; then
    echo "Error: This script requires bash (not sh). Please run with: ./$(basename "$0")" >&2
    exit 1
fi

# Require bash 4.0+ for associative arrays
if [[ ${BASH_VERSION%%.*} -lt 4 ]]; then
    echo "Error: This script requires bash 4.0 or later. Current version: $BASH_VERSION" >&2
    echo "Please upgrade bash or run with: ./$(basename "$0")" >&2
    exit 1
fi

###################################################################################
# Superform V2 Core Deployment Script
###################################################################################
# Description:
#   This script manages the deployment of Superform V2 CORE contracts to multiple networks
#   using Tenderly Virtual Networks (VNETs). It includes functionality for:
#   - Creating and managing VNETs for multiple chains
#   - Maintaining deployment salt counters for deterministic addresses
#   - Supporting both local development and CI environments
#   - Handling cleanup of resources on failure
#
# Directory Structure:
#   script/output/
#   ‚îú‚îÄ‚îÄ dev/                      # Development branch deployments
#   ‚îÇ   ‚îú‚îÄ‚îÄ latest.json          # Latest deployment info for dev branch
#   ‚îÇ   ‚îú‚îÄ‚îÄ 1/                   # Ethereum deployment outputs
#   ‚îÇ   ‚îú‚îÄ‚îÄ 8453/               # Base deployment outputs
#   ‚îÇ   ‚îî‚îÄ‚îÄ 10/                 # Optimism deployment outputs
#   ‚îú‚îÄ‚îÄ feat-xyz/                # Feature branch deployments
#   ‚îÇ   ‚îî‚îÄ‚îÄ ...                 # Same structure as dev/
#   ‚îî‚îÄ‚îÄ main/                    # Main branch deployments
#       ‚îî‚îÄ‚îÄ ...                 # Same structure as dev/
#
# File Organization:
#   - latest.json: Contains network-specific deployment info including:
#     - VNET IDs for active deployments
#     - Salt counters for deterministic addresses
#     - Contract addresses and metadata
#     - Timestamps for tracking deployment history
#
# Usage:
#   ./deploy_v2_vnet.sh_s3 <branch_name> [redeploy]
#   
#   Parameters:
#     branch_name: Name of the branch (required)
#     redeploy: Optional flag for demo branch only. When specified:
#               - Uses timestamp-based salt for new contract addresses
#               - Only allowed for "demo" branch
#               - Not allowed in CI environment (CI=true)
#
# Demo Branch Special Features:
#   - Fixed salt (1756453482) by default for consistent contract addresses
#   - Uses locked bytecode from script/locked-bytecode/ (without redeploy flag)
#   - Redeploy mode uses timestamp salt and regenerated bytecode for new addresses
#   - Bytecode checking via forge to show which contracts need deployment
#   - Deployment preview shows actual contract status on each network
#   - User confirmation prompt before deployment (non-redeploy mode)
#   - S3 upload diff showing contract changes
#
# Execution Modes:
#   1. Local Development:
#      - Detected by presence of 'op' command
#      - Uses 1Password for secrets
#      - Creates new VNETs for each run
#      - Does not maintain deployment history
#
#   2. CI Environment:
#      - Uses GitHub environment variables
#      - Stores latest.json in S3 bucket
#      - Maintains deployment history in branch-specific directories
#      - Reuses existing VNETs when possible
#      - Updates deployment records in latest.json
#
# Requirements:
#   - jq: For JSON processing
#   - curl: For API calls
#   - forge: For contract deployment
#   - op: For local secret management (local mode only)
#   - aws: For S3 operations (CI mode only)
#   - GitHub environment variables (CI mode only)
#
# Environment Variables:
#   Required for all modes:
#   - TENDERLY_ACCESS_KEY: Access key for Tenderly API
#   
#   Required for CI mode:
#   - GITHUB_REF_NAME: Branch name
#   - S3_BUCKET_NAME: S3 bucket name for storing latest.json
#
# Error Handling:
#   - Automatic cleanup of VNETs on failure
#   - Retries for API operations with exponential backoff
#   - Optimistic locking for file updates
#   - Comprehensive logging and error reporting
#
# Author: Superform Team
# Version: 1.0.0
###################################################################################

set -euo pipefail  # Exit on error, undefined var, pipe failure

###################################################################################
# Helper Functions
###################################################################################

# Logging function for consistent output
log() {
    local level=$1
    shift
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [$level] $*" >&2
}

# Environment detection
is_local_run() {
    # Check if branch name is 'local'
    [ "${BRANCH_NAME:-}" = "local" ]
    return $?
}

# Network name mapping
get_network_slug() {
    local network_id=$1
    case "$network_id" in
        1)
            echo "Ethereum"
            ;;
        8453)
            echo "Base"
            ;;
        10)
            echo "Optimism"
            ;;
        *)
            log "ERROR" "Unknown network ID: $network_id"
            return 1
            ;;
    esac
}

###################################################################################
# Configuration
###################################################################################

# Environment and Chain IDs
ETH_CHAIN_ID=1
BASE_CHAIN_ID=8453
OPTIMISM_CHAIN_ID=10

# Tenderly Configuration
API_BASE_URL="https://api.tenderly.co/api/v1"
TENDERLY_ACCOUNT="superform"
TENDERLY_PROJECT="v2"

# Script Arguments
# Store branch name as a global variable for is_local_run checks
BRANCH_NAME=$1
REDEPLOY_FLAG=${2:-}

# Detect if this is a development or main branch
IS_MAIN_OR_DEV=false
if [ "$BRANCH_NAME" = "dev" ] || [ "$BRANCH_NAME" = "main" ]; then
    IS_MAIN_OR_DEV=true
fi

# Demo branch specific logic
IS_DEMO_BRANCH=false
if [ "$BRANCH_NAME" = "demo" ]; then
    IS_DEMO_BRANCH=true
fi

# Set environment for forge scripts
FORGE_ENV=1  # Default to environment 1 for both local and CI

# Handle branch name logic
if [ "$BRANCH_NAME" = "local" ]; then
    log "INFO" "Local branch detected: $BRANCH_NAME. Using local deployment settings."
    GITHUB_REF_NAME="local"
    S3_BUCKET_NAME="vnet-state"
else
    # For all other branches (including main, dev, and custom branches)
    log "INFO" "Branch detected: $BRANCH_NAME. Using vnet-state bucket."
    GITHUB_REF_NAME="$BRANCH_NAME"
    S3_BUCKET_NAME="vnet-state"
fi

# Log branch name for debugging
log "INFO" "Running with branch name: $BRANCH_NAME"



# Validation
if [ -z "$BRANCH_NAME" ]; then
    echo "Error: Branch name is required"
    echo "Usage: $0 <branch_name> [redeploy]"
    echo "  branch_name: Name of the branch (required)"
    echo "  redeploy: Optional flag for demo branch to use timestamp salt (demo branch only)"
    exit 1
fi

# Demo branch redeploy validation
if [ "$REDEPLOY_FLAG" = "redeploy" ]; then
    if [ "$BRANCH_NAME" != "demo" ]; then
        echo "Error: 'redeploy' flag is only allowed for 'demo' branch"
        exit 1
    fi
    
    if [ "${CI:-false}" = "true" ]; then
        echo "Error: 'redeploy' flag is not allowed in CI environment"
        exit 1
    fi
    
    log "INFO" "Demo branch redeploy mode enabled - using timestamp salt"
elif [ -n "$REDEPLOY_FLAG" ]; then
    echo "Error: Invalid second argument '$REDEPLOY_FLAG'. Only 'redeploy' is allowed."
    echo "Usage: $0 <branch_name> [redeploy]"
    exit 1
fi


# Base output directory for local file operations
OUTPUT_BASE_DIR="script/output"


###################################################################################
# Authentication Setup
###################################################################################

# Check if we're in a local run and if the op command is available
if command -v op >/dev/null 2>&1; then
    log "INFO" "Running in local environment with 1Password CLI available"
    # For local runs with op available, get TENDERLY_ACCESS_KEY from 1Password
    TENDERLY_ACCESS_KEY=$(op read "op://5ylebqljbh3x6zomdxi3qd7tsa/TENDERLY_ACCESS_KEY/credential")
else
    
    # Source .env if any required variable is missing
    if [ -z "${GITHUB_REF_NAME:-}" ] || [ -z "${TENDERLY_ACCESS_KEY:-}" ]; then
        if [ ! -f .env ]; then
            log "ERROR" ".env file is required when environment variables are missing"
            exit 1
        fi
        log "INFO" "Loading missing variables from .env file"
        source .env
    fi
fi

###################################################################################
# Environment Validation
###################################################################################

# Validate Tenderly access key for all modes
if [ -z "${TENDERLY_ACCESS_KEY:-}" ]; then
    log "ERROR" "TENDERLY_ACCESS_KEY environment variable is required"
    exit 1
fi

# Validate CI-specific environment variables
if ! is_local_run && [ "$IS_MAIN_OR_DEV" = "true" ]; then
    if [ -z "${GITHUB_REF_NAME:-}" ]; then
        log "ERROR" "GITHUB_REF_NAME environment variable is required for CI mode"
        exit 1
    fi
fi

# Directory configuration based on branch type
if is_local_run; then
    # For local runs only
    BRANCH_DIR="$OUTPUT_BASE_DIR/local"
    # Create local output directories
    for network in 1 8453 10; do
        mkdir -p "$BRANCH_DIR/$network"
    done
else
    # For CI/remote runs (dev, main, and custom branches)
    # Handle feature branches differently
    if [[ "$GITHUB_REF_NAME" == feat/* ]]; then
        # Extract feature name without feat/ prefix
        FEATURE_NAME=${GITHUB_REF_NAME#feat/}
        BRANCH_DIR="$OUTPUT_BASE_DIR/feat/$FEATURE_NAME"
    else
        # For dev, main, and custom branches
        BRANCH_DIR="$OUTPUT_BASE_DIR/$GITHUB_REF_NAME"
    fi
    
    BRANCH_LATEST_FILE="$BRANCH_DIR/latest.json"
    
    # Create branch output directories
    for network in 1 8453 10; do
        mkdir -p "$BRANCH_DIR/$network"
    done
fi

# Function to read branch-level latest file
read_branch_latest() {
    latest_file_path="/tmp/read_branch_latest_$$.json"

    log "DEBUG" "Environment check: S3_BUCKET_NAME=$S3_BUCKET_NAME, GITHUB_REF_NAME=$GITHUB_REF_NAME"
    log "DEBUG" "Attempting to download from S3: s3://$S3_BUCKET_NAME/$GITHUB_REF_NAME/latest.json to $latest_file_path"
    
    if aws s3 cp "s3://$S3_BUCKET_NAME/$GITHUB_REF_NAME/latest.json" "$latest_file_path" --quiet; then
        log "INFO" "Successfully downloaded latest.json from S3"
        log "DEBUG" "Downloaded file size: $(wc -c < "$latest_file_path" 2>/dev/null || echo "0") bytes"
        
        # Show first few lines of downloaded file for debugging
        log "DEBUG" "First 500 chars of downloaded file:"
        head -c 500 "$latest_file_path" >&2
        echo "" >&2

        # Read the file and validate JSON
        content=$(cat "$latest_file_path")
        log "DEBUG" "Content length after reading: ${#content} characters"

        # Validate the content from file
        if ! echo "$content" | jq '.' >/dev/null 2>&1; then
            log "ERROR" "Invalid JSON in latest file, resetting to default"
            log "ERROR" "Response: $content"
            content="{\"networks\":{},\"updated_at\":null}"
        else
            log "INFO" "Successfully validated latest.json from S3"
            # Check if contracts are empty
            local ethereum_contracts=$(echo "$content" | jq -r '.networks.Ethereum.contracts // {}' 2>/dev/null)
            local contract_count=$(echo "$ethereum_contracts" | jq -r '. | length' 2>/dev/null)
            log "DEBUG" "Ethereum contracts count from downloaded file: $contract_count"
        fi
    else
        log "WARN" "latest.json not found in S3, initializing empty file"
        log "DEBUG" "AWS S3 cp command failed for: s3://$S3_BUCKET_NAME/$GITHUB_REF_NAME/latest.json"
        content="{\"networks\":{},\"updated_at\":null}"
    fi
   
    echo "$content"
}

# Generate salt for a network
get_salt() {    
    # Demo branch salt logic
    if [ "$IS_DEMO_BRANCH" = true ]; then
        if [ "$REDEPLOY_FLAG" = "redeploy" ]; then
            # Use current timestamp for redeploy
            local timestamp=$(date +%s)
            log "INFO" "Demo branch redeploy: using timestamp salt $timestamp"
            echo "$timestamp"
        else
            # Use fixed timestamp for demo branch
            local fixed_salt="1756453482"
            log "INFO" "Demo branch: using fixed salt $fixed_salt"
            echo "$fixed_salt"
        fi
    else
        # For all other branches, use current timestamp as before
        local timestamp=$(date +%s)
        echo "$timestamp"
    fi
}

###################################################################################
# VNET Management Functions
###################################################################################

# Array to store VNET IDs for cleanup
declare -a VNET_IDS

#delete_vnet() {
#    local vnet_id=$1
#    log "INFO" "Deleting VNET: $vnet_id"
#    curl -s -X DELETE \
#        "${API_BASE_URL}/account/${TENDERLY_ACCOUNT}/project/${TENDERLY_PROJECT}/vnets/${vnet_id}" \
#        -H "X-Access-Key: ${TENDERLY_ACCESS_KEY}"
#}

#cleanup_vnets() {
#    log "INFO" "Cleaning up VNETs..."
#    for vnet_id in "${VNET_IDS[@]}"; do
#        delete_vnet "$vnet_id"
#    done
#}

# Set up trap to cleanup VNETs on script exit due to error
#trap 'cleanup_vnets' ERR

generate_slug() {
    local network=$1
    local output="${BRANCH_NAME//\//-}-${network}"
    # Convert to lowercase, replace spaces with hyphens, remove special chars
    local output=$(echo "$output" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
    echo "$output"
}

# Function to check if a VNET with a specific slug exists in Tenderly
check_existing_vnet_by_slug() {
    local slug=$1
    local account=$2
    local project=$3
    local access_key=$4
    
    log "INFO" "Checking if a VNET with slug '$slug' already exists in Tenderly"
    
    # Validate inputs
    if [ -z "$slug" ] || [ -z "$account" ] || [ -z "$project" ] || [ -z "$access_key" ]; then
        log "ERROR" "Missing required parameters for VNET check"
        log "DEBUG" "slug=$slug, account=$account, project=$project, access_key=[${access_key:+SET}]"
        return 1
    fi
    
    # Get list of all VNETs from Tenderly
    log "DEBUG" "Making API call to list VNETs..."
    local vnet_list
    if ! vnet_list=$(curl -s -X GET \
        "${API_BASE_URL}/account/${account}/project/${project}/vnets" \
        -H "X-Access-Key: ${access_key}" 2>&1); then
        log "ERROR" "Failed to make API call to list VNETs"
        log "ERROR" "curl error: $vnet_list"
        return 1
    fi
    
    log "DEBUG" "API response received, length: ${#vnet_list}"
    
    # Check if response is valid JSON
    if ! echo "$vnet_list" | jq '.' >/dev/null 2>&1; then
        log "ERROR" "Invalid JSON response when listing VNETs"
        log "ERROR" "Response (first 500 chars): ${vnet_list:0:500}"
        return 1
    fi
    
    log "DEBUG" "API response is valid JSON, checking for existing VNET..."
    
    # Check if the VNET with this slug exists
    local existing_vnet_id
    if ! existing_vnet_id=$(echo "$vnet_list" | jq -r --arg slug "$slug" '.[] | select(.slug==$slug) | .id // empty' 2>&1); then
        log "ERROR" "Failed to parse VNET list with jq"
        log "ERROR" "jq error: $existing_vnet_id"
        return 1
    fi
    
    if [ -n "$existing_vnet_id" ]; then
        log "INFO" "Found existing VNET with slug '$slug', ID: $existing_vnet_id"
        
        # Get details of the VNET to extract RPC URL
        log "DEBUG" "Getting VNET details for ID: $existing_vnet_id"
        local vnet_details
        if ! vnet_details=$(curl -s -X GET \
            "${API_BASE_URL}/account/${account}/project/${project}/vnets/${existing_vnet_id}" \
            -H "X-Access-Key: ${access_key}" 2>&1); then
            log "ERROR" "Failed to get VNET details"
            log "ERROR" "curl error: $vnet_details"
            return 1
        fi
        
        local admin_rpc
        if ! admin_rpc=$(echo "$vnet_details" | jq -r '.rpcs[] | select(.name=="Admin RPC") | .url' 2>&1); then
            log "ERROR" "Failed to extract admin RPC from VNET details"
            log "ERROR" "jq error: $admin_rpc"
            return 1
        fi
        
        if [ -n "$admin_rpc" ]; then
            log "INFO" "Successfully extracted admin RPC: $admin_rpc"
            echo "${admin_rpc}|${existing_vnet_id}"
            return 0
        else
            log "WARN" "No admin RPC found in VNET details"
        fi
    else
        log "DEBUG" "No existing VNET found with slug '$slug'"
    fi
    
    # No existing VNET found or couldn't extract details
    return 1
}

# Check for existing VNET in branch latest file and create if not found
check_vnets() {
    local network_slug=$1
    local network_id=$2
    
    # Check if we can reuse an existing VNET
    log "INFO" "Checking for existing VNET for network: $network_slug"

    # Step 1: Check in S3/branch latest file
    content=$(read_branch_latest)
    log "DEBUG: Content received from read_branch_latest: $content"

    vnet_id=$(echo "$content" | jq -r ".networks[\"$network_slug\"].vnet_id // empty")
    log "DEBUG" "VNET ID from latest file: $vnet_id"
    
    if [ -n "$vnet_id" ]; then
        log "INFO" "Found existing VNET ID in S3: $vnet_id"
        # Check if VNET still exists in Tenderly and has the correct slug
        local tenderly_response=$(curl -s -X GET \
            "${API_BASE_URL}/account/${TENDERLY_ACCOUNT}/project/${TENDERLY_PROJECT}/vnets/${vnet_id}" \
            -H "X-Access-Key: ${TENDERLY_ACCESS_KEY}")
        
        if [ "$(echo "$tenderly_response" | jq -r '.id')" == "$vnet_id" ]; then
            # Validate that the VNET has the expected slug for this branch/network
            local expected_slug=$(generate_slug "$network_slug")
            local actual_slug=$(echo "$tenderly_response" | jq -r '.slug')
            
            if [ "$actual_slug" == "$expected_slug" ]; then
                local admin_rpc=$(echo "$tenderly_response" | jq -r '.rpcs[] | select(.name=="Admin RPC") | .url')
                if [ -n "$admin_rpc" ]; then
                    log "INFO" "Reusing VNET from S3 state with correct slug: $actual_slug"
                    echo "${admin_rpc}|${vnet_id}"
                    return 0
                fi
            else
                log "WARN" "VNET ID $vnet_id exists but has wrong slug. Expected: $expected_slug, Found: $actual_slug"
                log "WARN" "This indicates S3 file corruption. Will create new VNET with correct slug."
            fi
        fi
        log "INFO" "VNET ID exists in branch file but not valid for reuse"
    fi
    
    # Step 2: Check if there's already a VNET with this slug in Tenderly (not in our state)
    slug=$(generate_slug "$network_slug")
    log "INFO" "Checking if VNET with slug '$slug' already exists in Tenderly"
    log "DEBUG" "Generated slug: $slug for network: $network_slug"
    log "DEBUG" "TENDERLY_ACCOUNT: $TENDERLY_ACCOUNT, TENDERLY_PROJECT: $TENDERLY_PROJECT"
    
    log "DEBUG" "Calling check_existing_vnet_by_slug function..."
    local existing_vnet
    # Temporarily disable exit on error for this specific call
    set +e
    existing_vnet=$(check_existing_vnet_by_slug "$slug" "$TENDERLY_ACCOUNT" "$TENDERLY_PROJECT" "$TENDERLY_ACCESS_KEY")
    local check_result=$?
    set -e
    
    if [ $check_result -eq 0 ]; then
        log "INFO" "Found and reusing existing VNET from Tenderly with slug: $slug"
        log "DEBUG" "Existing VNET response: $existing_vnet"
        echo "$existing_vnet"
        return 0
    else
        log "DEBUG" "check_existing_vnet_by_slug returned non-zero status, proceeding to create new VNET"
    fi

    # Step 3: If no existing VNET found, create a new one
    log "INFO" "No existing VNET found. Creating new VNET for $network_slug with slug: $slug"
    log "DEBUG" "Calling create_virtual_testnet with parameters: slug=$slug, network_id=$network_id"
    
    local response
    if response=$(create_virtual_testnet "$slug" "$network_id" "$TENDERLY_ACCOUNT" "$TENDERLY_PROJECT" "$TENDERLY_ACCESS_KEY"); then
        log "INFO" "Successfully created new VNET"
        log "DEBUG" "New VNET response: $response"
        echo "$response"
        return 0
    else
        log "ERROR" "Failed to create new VNET"
        return 1
    fi
}

create_virtual_testnet() {
    local slug=$1
    local network_id=$2
    local account_name=$3
    local project_name=$4
    local access_key=$5
    
    log "INFO" "Creating TestNet with slug: $slug"
    
    # Determine custom chain ID based on network_id
    local custom_chain_id
    case "$network_id" in
        1)
            custom_chain_id=1
            ;;
        8453)
            custom_chain_id=8453
            ;;
        10)
            custom_chain_id=10
            ;;
        *)
            custom_chain_id=$network_id
            ;;
    esac

    # Construct JSON payload
    local json_data=$(cat <<EOF
{
    "slug": "$slug",
    "display_name": "$slug",
    "fork_config": {
        "network_id": $network_id,
        "block_number": "latest"
    },
    "virtual_network_config": {
        "chain_config": {
            "chain_id": $custom_chain_id
        }
    },
    "sync_state_config": {
        "enabled": false
    },
    "explorer_page_config": {
        "enabled": false,
        "verification_visibility": "src"
    }
}
EOF
)

    # Make API request
    local response=$(curl -s -X POST \
        "${API_BASE_URL}/account/${account_name}/project/${project_name}/vnets" \
        -H "Accept: application/json" \
        -H "Content-Type: application/json" \
        -H "X-Access-Key: ${access_key}" \
        -d "$json_data")
        
    # Debug the raw response
    log "DEBUG" "Raw Tenderly API response: $response"
    
    # Check if response is valid JSON
    if ! echo "$response" | jq '.' >/dev/null 2>&1; then
        log "ERROR" "Invalid JSON response from Tenderly API"
        log "ERROR" "Response: $response"
        return 1
    fi
    
    # Check for API error responses
    if [ "$(echo "$response" | jq -r '.error.message // empty')" != "" ]; then
        log "ERROR" "Tenderly API error: $(echo "$response" | jq -r '.error.message')"
        return 1
    fi
    
    # Check if response has the expected structure
    if ! echo "$response" | jq -e '.rpcs' >/dev/null 2>&1; then
        log "ERROR" "Unexpected response format from Tenderly API (missing rpcs field)"
        log "ERROR" "Full response: $response"
        return 1
    fi

    # Extract RPC URLs and VNET ID using jq with error handling
    local admin_rpc=$(echo "$response" | jq -r '.rpcs[] | select(.name=="Admin RPC") | .url')
    local vnet_id=$(echo "$response" | jq -r '.id')

    if [ -z "$admin_rpc" ] || [ -z "$vnet_id" ]; then
        log "ERROR" "Failed to extract required fields from Tenderly API response"
        log "ERROR" "Admin RPC: $admin_rpc"
        log "ERROR" "VNET ID: $vnet_id"
        log "ERROR" "Full response: $response"
        return 1
    fi
    
    log "SUCCESS" "VNET created successfully"
    echo "${admin_rpc}|${vnet_id}"
}

set_initial_balance() {
    local rpc_url=$1
    log "INFO" "Setting initial balance for RPC: $rpc_url"
    curl $rpc_url \
        -X POST \
        -H "Content-Type: application/json" \
        -d '{
            "jsonrpc": "2.0",
            "method": "tenderly_setBalance",
            "params": [
            [
            "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
            ],
            "0xDE0B6B3A7640000"
            ],
            "id": "1234"
        }'
}

###################################################################################
# Contract Diff Functions (for demo branch)
###################################################################################

# Function to check if there are any changes for a network (adapted from upload_contracts_to_s3.sh)
has_contract_changes() {
    local existing_contracts=$1
    local new_contracts=$2
    
    # Validate JSON inputs
    if ! echo "$existing_contracts" | jq '.' >/dev/null 2>&1; then
        existing_contracts="{}"
    fi
    if ! echo "$new_contracts" | jq '.' >/dev/null 2>&1; then
        return 1
    fi
    
    # Check for new contracts (contracts that don't exist in S3)
    local new_contract_count=$(echo "$new_contracts" | jq --argjson existing "$existing_contracts" '
        [to_entries[] | select(.key as $k | $existing | has($k) | not)] | length
    ')
    
    # Check for updated contracts (contracts that exist but with different addresses)
    local updated_contract_count=$(echo "$new_contracts" | jq --argjson existing "$existing_contracts" '
        [to_entries[] | select(.key as $k | .value as $v | $existing | has($k) and (.[$k] != $v))] | length
    ')
    
    # Check for removed contracts (contracts that exist in S3 but not in new deployment)
    # Exclude Nexus contracts and banned contracts from being considered removable
    local removed_contract_count=$(echo "$existing_contracts" | jq --argjson new_contracts "$new_contracts" '
        [to_entries[] | select(.key as $k | $new_contracts | has($k) | not and ($k != "Nexus" and $k != "NexusBootstrap" and $k != "NexusAccountFactory" and $k != "SuperGovernor" and $k != "SuperVaultAggregator" and $k != "ECDSAPPSOracle"))] | length
    ')
    
    # Return true if there are any new, updated, or removed contracts
    local total_changes=$((new_contract_count + updated_contract_count + removed_contract_count))
    return $([[ $total_changes -gt 0 ]] && echo 0 || echo 1)
}

# Function to show contract differences for a network (adapted from upload_contracts_to_s3.sh)
show_contract_diff() {
    local network_name=$1
    local existing_contracts=$2
    local new_contracts=$3
    
    # Colors for output
    local RED='\033[0;31m'
    local GREEN='\033[0;32m'
    local YELLOW='\033[1;33m'
    local CYAN='\033[0;36m'
    local NC='\033[0m'
    
    echo -e "${CYAN}üìç $network_name Changes:${NC}"
    
    # Validate JSON inputs
    if ! echo "$existing_contracts" | jq '.' >/dev/null 2>&1; then
        existing_contracts="{}"
    fi
    if ! echo "$new_contracts" | jq '.' >/dev/null 2>&1; then
        echo -e "  ${RED}Error: Invalid JSON for new contracts${NC}"
        return 1
    fi
    
    # Show new contracts (contracts that don't exist in S3)
    local new_contract_names=$(echo "$new_contracts" | jq -r --argjson existing "$existing_contracts" '
        to_entries[] | select(.key as $k | $existing | has($k) | not) | .key
    ' | tr '\n' ' ')
    
    # Show updated contracts (contracts that exist but with different addresses)
    local updated_contract_names=$(echo "$new_contracts" | jq -r --argjson existing "$existing_contracts" '
        to_entries[] | select(.key as $k | .value as $v | $existing | has($k) and (.[$k] != $v)) | .key
    ' | tr '\n' ' ')
    
    # Show removed contracts (contracts that exist in S3 but not in new deployment)
    # Exclude Nexus contracts and banned contracts from being shown as removed
    local removed_contract_names=$(echo "$existing_contracts" | jq -r --argjson new_contracts "$new_contracts" '
        to_entries[] | select(.key as $k | $new_contracts | has($k) | not and ($k != "Nexus" and $k != "NexusBootstrap" and $k != "NexusAccountFactory" and $k != "SuperGovernor" and $k != "SuperVaultAggregator" and $k != "ECDSAPPSOracle")) | .key
    ' | tr '\n' ' ')
    
    local changes_shown=false
    
    if [ -n "$new_contract_names" ] && [ "${new_contract_names// /}" != "" ]; then
        local new_count=$(echo "$new_contract_names" | wc -w | tr -d ' ')
        echo -e "  ${GREEN}+ ${new_count} new contracts${NC}"
        for contract in $new_contract_names; do
            if [ -n "$contract" ]; then
                local addr=$(echo "$new_contracts" | jq -r ".$contract")
                echo -e "    ${GREEN}+ $contract: $addr${NC}"
            fi
        done
        changes_shown=true
    fi
    
    if [ -n "$updated_contract_names" ] && [ "${updated_contract_names// /}" != "" ]; then
        local updated_count=$(echo "$updated_contract_names" | wc -w | tr -d ' ')
        echo -e "  ${YELLOW}~ ${updated_count} updated contracts${NC}"
        for contract in $updated_contract_names; do
            if [ -n "$contract" ]; then
                local old_addr=$(echo "$existing_contracts" | jq -r ".$contract")
                local new_addr=$(echo "$new_contracts" | jq -r ".$contract")
                echo -e "    ${YELLOW}~ $contract: $old_addr ‚Üí $new_addr${NC}"
            fi
        done
        changes_shown=true
    fi
    
    if [ -n "$removed_contract_names" ] && [ "${removed_contract_names// /}" != "" ]; then
        local removed_count=$(echo "$removed_contract_names" | wc -w | tr -d ' ')
        echo -e "  ${RED}- ${removed_count} removed contracts${NC}"
        for contract in $removed_contract_names; do
            if [ -n "$contract" ]; then
                local old_addr=$(echo "$existing_contracts" | jq -r ".$contract")
                echo -e "    ${RED}- $contract: $old_addr${NC}"
            fi
        done
        changes_shown=true
    fi
    
    if [ "$changes_shown" = false ]; then
        echo -e "  ${CYAN}No changes (all contracts already up to date)${NC}"
    fi
    
    echo ""
}

# Function to check V2 Core addresses on a network using forge (similar to staging script)
check_v2_addresses_on_network() {
    local network_id=$1
    local network_slug=$2
    local rpc_url=$3
    
    log "INFO" "Checking V2 Core addresses for $network_slug (Chain ID: $network_id)..."
    log "DEBUG" "RPC URL: $rpc_url"
    log "DEBUG" "FORGE_ENV: $FORGE_ENV"
    
    # Check if RPC URL is set
    if [[ -z "$rpc_url" ]]; then
        log "ERROR" "RPC URL is not set or empty for $network_slug"
        return 1
    fi
    
    # Capture the full output to parse deployment status
    local check_output
    local forge_exit_code
    
    # For env 1 (VNET), use the new function with salt namespace
    local salt_value=$(get_salt)
    
    # Run forge script with check flag and salt namespace (for env 1)
    
    check_output=$(forge script script/DeployV2Core.s.sol:DeployV2Core \
        --sig 'run(bool,uint256,uint64,string)' true $FORGE_ENV $network_id "$salt_value" \
        --rpc-url "$rpc_url" \
        --chain $network_id \
        -vv 2>&1)
    forge_exit_code=$?

    
    # Check if forge command failed
    if [[ $forge_exit_code -ne 0 ]]; then
        log "ERROR" "Forge script failed with exit code $forge_exit_code for $network_slug"
        log "ERROR" "Full forge output:"
        echo "$check_output" | sed 's/^/     /' >&2
        return 1
    fi
    
    # Display the relevant output lines (like staging script does)
    # Filter and sanitize the output to prevent shell parsing errors
    local relevant_output
    relevant_output=$(printf "%s\n" "$check_output" | grep -e "Addr" -e "already deployed" -e "Code Size" || true)
    if [[ -n "$relevant_output" ]]; then
        log "INFO" "  üìã Contract Deployment Status:"
        printf "%s\n" "$relevant_output" | sed 's/^/     /' >&2
    fi
    
    # Extract deployment counts from the summary line
    # Use printf to safely handle the output and avoid shell interpretation
    local summary_line
    summary_line=$(printf "%s\n" "$check_output" | grep "=====> On this chain we have" || true)
    
    # Extract contract availability information safely
    local availability_info
    availability_info=$(printf "%s\n" "$check_output" | grep -A5 "=== Contract Availability Analysis ===" || true)
    
    if [[ -n "$availability_info" ]]; then
        log "INFO" "  üìä Contract Availability Analysis:"
        printf "%s\n" "$availability_info" | sed 's/^/     /' >&2
        
        # Check for skipped contracts
        local skipped_info
        skipped_info=$(printf "%s\n" "$check_output" | grep -A10 "=== Contracts SKIPPED due to missing configurations ===" || true)
        if [[ -n "$skipped_info" ]]; then
            log "WARN" "  ‚ö†Ô∏è  Skipped Contracts:"
            printf "%s\n" "$skipped_info" | sed 's/^/     /' >&2
        fi
    fi
    
    if [[ -n "$summary_line" ]]; then
        # Parse: "=====> On this chain we have X contracts already deployed out of Y"
        # Use safer parsing to avoid shell interpretation issues
        local deployed_count
        local total_count
        
        deployed_count=$(printf "%s\n" "$summary_line" | grep -o "have [0-9]\+ contracts" | grep -o "[0-9]\+" || echo "0")
        total_count=$(printf "%s\n" "$summary_line" | grep -o "out of [0-9]\+" | grep -o "[0-9]\+" || echo "0")
        
        if [[ -n "$deployed_count" && -n "$total_count" ]] && [[ "$deployed_count" =~ ^[0-9]+$ ]] && [[ "$total_count" =~ ^[0-9]+$ ]]; then
            echo "$deployed_count:$total_count:$network_slug"
            return 0
        else
            log "ERROR" "Could not parse deployment counts from summary line for $network_slug"
            log "DEBUG" "Deployed count: '$deployed_count', Total count: '$total_count'"
            log "DEBUG" "Summary line: '$summary_line'"
            return 1
        fi
    else
        log "WARN" "Could not find deployment summary in forge output for $network_slug"
        log "DEBUG" "Searched for pattern: '=====> On this chain we have'"
        log "DEBUG" "Full forge output for debugging:"
        echo "$check_output" | sed 's/^/     /' >&2
        echo "0:0:$network_slug"
        return 1
    fi
}

# Function to preview bytecode differences for demo branch using forge checks
preview_demo_deployment_diff() {
    log "INFO" "Previewing deployment differences for demo branch using forge checks..."
    
    # Colors for output
    local RED='\033[0;31m'
    local GREEN='\033[0;32m'
    local YELLOW='\033[1;33m'
    local CYAN='\033[0;36m'
    local WHITE='\033[1;37m'
    local NC='\033[0m'
    
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë${WHITE}                        üìã Demo Branch Deployment Preview üìã                         ${CYAN}‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    
    local has_changes=false
    local total_to_deploy=0
    local total_already_deployed=0
    
    # Check each network using forge
    i=0
    for network in 1 8453 10; do
        local network_slug=$(get_network_slug "$network")
        local vnet_response="${VNET_RESPONSES[$i]}"
        local admin_rpc=$(echo "$vnet_response" | cut -d'|' -f1)
        
        echo -e "${CYAN}üìç Checking $network_slug (Chain ID: $network)...${NC}"
        
        # Run forge check to see current deployment status
        local check_result
        if check_result=$(check_v2_addresses_on_network "$network" "$network_slug" "$admin_rpc"); then
            local deployed_count=$(echo "$check_result" | cut -d':' -f1)
            local total_count=$(echo "$check_result" | cut -d':' -f2)
            
            total_already_deployed=$((total_already_deployed + deployed_count))
            total_to_deploy=$((total_to_deploy + total_count))
            
            if [ "$deployed_count" -lt "$total_count" ]; then
                local missing_count=$((total_count - deployed_count))
                echo -e "  ${YELLOW}‚ö†Ô∏è  $missing_count contracts need deployment (${deployed_count}/${total_count} already deployed)${NC}"
                has_changes=true
            else
                echo -e "  ${GREEN}‚úÖ All contracts already deployed (${deployed_count}/${total_count})${NC}"
            fi
            
            # Show redeploy impact
            if [ "$REDEPLOY_FLAG" = "redeploy" ]; then
                echo -e "  ${YELLOW}üîÑ REDEPLOY MODE: All contracts will get NEW addresses (timestamp salt)${NC}"
                has_changes=true
            else
                echo -e "  ${CYAN}üîí FIXED SALT MODE: Contracts will use consistent addresses${NC}"
            fi
        else
            log "WARN" "Could not check deployment status for $network_slug"
            echo -e "  ${RED}‚ùå Unable to determine deployment status${NC}"
        fi
        
        echo ""
        i=$((i + 1))
    done
    
    # Summary
    echo -e "${CYAN}üìä Overall Status:${NC}"
    echo -e "  ${WHITE}Total contracts already deployed: $total_already_deployed${NC}"
    echo -e "  ${WHITE}Total contracts expected: $total_to_deploy${NC}"
    local missing_total=$((total_to_deploy - total_already_deployed))
    echo -e "  ${WHITE}Contracts needing deployment: $missing_total${NC}"
    
    if [ "$REDEPLOY_FLAG" = "redeploy" ]; then
        echo -e "  ${YELLOW}üîÑ Redeploy mode will create new addresses for ALL contracts${NC}"
    fi
    
    echo ""
    
    # Debug output for troubleshooting
    log "DEBUG" "has_changes=$has_changes, missing_total=$missing_total"
    
    if [ "$has_changes" = true ] || [ "$missing_total" -gt 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Changes detected - deployment will modify or add contracts${NC}"
        log "DEBUG" "preview_demo_deployment_diff returning 0 (true) - changes detected"
        return 0
    else
        echo -e "${CYAN}‚ÑπÔ∏è  All contracts already deployed with expected addresses${NC}"
        log "DEBUG" "preview_demo_deployment_diff returning 1 (false) - no changes needed"
        return 1
    fi
}

# Function to show S3 diff for demo branch
show_demo_s3_diff() {
    local existing_s3_content=$1
    
    # Colors for output
    local RED='\033[0;31m'
    local GREEN='\033[0;32m'
    local YELLOW='\033[1;33m'
    local CYAN='\033[0;36m'
    local WHITE='\033[1;37m'
    local NC='\033[0m'
    
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë${WHITE}                       üì§ Demo Branch S3 Upload Preview üì§                            ${CYAN}‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    
    local has_changes=false
    
    # Check each network for contract changes
    for network in 1 8453 10; do
        local network_slug=$(get_network_slug "$network")
        
        # Get existing contracts from S3
        local existing_contracts=$(echo "$existing_s3_content" | jq -r ".networks[\"$network_slug\"].contracts // {}")
        
        # Read new contracts from deployment output files
        local contracts_file="$OUTPUT_BASE_DIR/$GITHUB_REF_NAME/$network/$network_slug-latest.json"
        
        if [ -f "$contracts_file" ]; then
            # Read and validate contracts file
            local new_contracts=$(tr -d '\r' < "$contracts_file")
            
            if new_contracts=$(echo "$new_contracts" | jq -c '.' 2>/dev/null); then
                # Check for changes and show diff
                if has_contract_changes "$existing_contracts" "$new_contracts"; then
                    show_contract_diff "$network_slug" "$existing_contracts" "$new_contracts"
                    has_changes=true
                else
                    echo -e "${CYAN}üìç $network_slug: No changes detected${NC}"
                fi
            else
                log "WARN" "Failed to parse contracts file for $network_slug"
            fi
        else
            log "WARN" "No contracts file found for $network_slug"
        fi
    done
    
    if [ "$has_changes" = false ]; then
        echo -e "${CYAN}‚ÑπÔ∏è  No contract changes to upload to S3${NC}"
    fi
    
    echo ""
    
    # Return 0 if there are changes, 1 if no changes
    return $([[ "$has_changes" = true ]] && echo 0 || echo 1)
}

###################################################################################
# Save VNET Information
###################################################################################

save_vnet_info() {
    local is_local=$1
    log "INFO" "Saving VNET information..."
    
    # Skip uploading empty VNET info - only upload after contracts are deployed
    log "INFO" "VNET information cached - will be included with contract data upload"
    return 0
    
    # Initialize content
    content="{\"networks\":{},\"updated_at\":null}"
    local latest_file
    
    # Always use S3 for file operations
    latest_file_path="/tmp/save_vnet_info_$$.json"
    if aws s3 cp "s3://$S3_BUCKET_NAME/$GITHUB_REF_NAME/latest.json" "$latest_file_path" --quiet 2>/dev/null; then
        content=$(cat "$latest_file_path")
        if ! echo "$content" | jq '.' >/dev/null 2>&1; then
            content="{\"networks\":{},\"updated_at\":null}"
        fi
    fi
    
    # Update VNET information only
    i=0
    for network in 1 8453 10; do
        network_slug=$(get_network_slug "$network")
        vnet_id=$(echo "${VNET_RESPONSES[$i]}" | cut -d'|' -f2)
        
        if [ -n "$vnet_id" ]; then
            # Update only VNET information
            content=$(echo "$content" | jq \
                --arg slug "$network_slug" \
                --arg vnet "$vnet_id" \
                '.networks[$slug] = {
                    "vnet_id": $vnet,
                    "contracts": {}
                }')
        fi
        
        i=$((i + 1))
    done
    
    # Update timestamp
    content=$(echo "$content" | jq --arg time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" '.updated_at = $time')
    
    # Always use S3 for file operations, even for local runs
    echo "$content" | jq '.' > "/tmp/latest.json"
    if aws s3 cp "/tmp/latest.json" "s3://$S3_BUCKET_NAME/$GITHUB_REF_NAME/latest.json" --quiet; then
        log "INFO" "VNET information successfully uploaded to S3"
    else
        log "WARN" "Failed to upload VNET information to S3"
    fi
}

###################################################################################
# Initialize Output Directories and Files
###################################################################################

# Initialize output files
initialize_output_files() {
    log "INFO" "Initializing output directories and files..."
    log "INFO" "Branch directory: $BRANCH_DIR"
    
    for network in 1 8453 10; do
        network_slug=$(get_network_slug "$network")
        output_dir="$BRANCH_DIR/$network"
        output_file="$output_dir/$network_slug-latest.json"
        
        # Create directory if it doesn't exist
        mkdir -p "$output_dir"
        log "INFO" "Created directory: $output_dir"
        
        # Create initial JSON file if it doesn't exist
        if [ ! -f "$output_file" ]; then
            log "INFO" "Creating initial JSON file: $output_file"
            echo "{}" > "$output_file"
            # Verify file was created
            if [ -f "$output_file" ]; then
                log "INFO" "Successfully created file: $output_file"
            else
                log "ERROR" "Failed to create file: $output_file"
            fi
        fi
    done
}

# Initialize before deployments
initialize_output_files

###################################################################################
# Main Deployment Logic
###################################################################################

# First phase: Create or get VNETs for all networks
# Store responses in indexed arrays matching the network order
declare -a VNET_RESPONSES

for network in 1 8453 10; do
    network_slug=$(get_network_slug "$network")
    response=$(check_vnets "$network_slug" "$network")
    VNET_RESPONSES+=("$response")
done

# Second phase: Generate salts for each network
network_slug=$(get_network_slug "1")
ETH_SALT=$(get_salt)
log "INFO" "Generated ETH_SALT: $ETH_SALT"

network_slug=$(get_network_slug "8453")
BASE_SALT=$(get_salt)
log "INFO" "Generated BASE_SALT: $BASE_SALT"

network_slug=$(get_network_slug "10")
OPTIMISM_SALT=$(get_salt)
log "INFO" "Generated OPTIMISM_SALT: $OPTIMISM_SALT"

# Validate salts to ensure they're positive integers
if ! [[ "$ETH_SALT" =~ ^[0-9]+$ ]] || [ "$ETH_SALT" -le 0 ]; then
    log "WARN" "Invalid ETH_SALT: $ETH_SALT. Using fallback value."
    ETH_SALT=1
fi

if ! [[ "$BASE_SALT" =~ ^[0-9]+$ ]] || [ "$BASE_SALT" -le 0 ]; then
    log "WARN" "Invalid BASE_SALT: $BASE_SALT. Using fallback value."
    BASE_SALT=1
fi

if ! [[ "$OPTIMISM_SALT" =~ ^[0-9]+$ ]] || [ "$OPTIMISM_SALT" -le 0 ]; then
    log "WARN" "Invalid OPTIMISM_SALT: $OPTIMISM_SALT. Using fallback value."
    OPTIMISM_SALT=1
fi

# Third phase: Store network-specific variables
i=0
for network in 1 8453 10; do
    vnet_response="${VNET_RESPONSES[$i]}"
    vnet_id=$(echo "$vnet_response" | cut -d'|' -f2)
    admin_rpc=$(echo "$vnet_response" | cut -d'|' -f1)
    
    case "$network" in
        1)
            ETH_VNET_ID="$vnet_id"
            export ETH_MAINNET="$admin_rpc"
            ;;
        8453)
            BASE_VNET_ID="$vnet_id"
            export BASE_MAINNET="$admin_rpc"
            ;;
        10)
            OPTIMISM_VNET_ID="$vnet_id"
            export OPTIMISM_MAINNET="$admin_rpc"
            ;;
    esac
    
    VNET_IDS+=("$vnet_id")
    i=$((i + 1))
done

# Export TENDERLY_ACCESS_KEY if it's not already exported
if [ -n "$TENDERLY_ACCESS_KEY" ]; then
    export TENDERLY_ACCESS_KEY
fi

# Export environment variables needed for the deployment script
if ! is_local_run; then
    export CI=true
    export GITHUB_REF_NAME="$GITHUB_REF_NAME"
else
    # For local runs, we still want to use branch-specific directories for non-local branches
    if [ "$BRANCH_NAME" != "local" ]; then
        export CI=true
        export GITHUB_REF_NAME="$BRANCH_NAME"
    else
        export CI=false
    fi
fi

log "INFO" "Environment variables exported"
log "DEBUG" "CI=${CI:-false}, GITHUB_REF_NAME=${GITHUB_REF_NAME:-not_set}"

# Demo branch preview and confirmation (only for demo branch without redeploy flag)
DEMO_HAS_DEPLOYMENT_CHANGES=true  # Default to true for non-demo branches
if [ "$IS_DEMO_BRANCH" = true ] && [ "$REDEPLOY_FLAG" != "redeploy" ]; then
    log "INFO" "Demo branch detected - showing deployment preview"
    
    if preview_demo_deployment_diff; then
        DEMO_HAS_DEPLOYMENT_CHANGES=true
        log "DEBUG" "Set DEMO_HAS_DEPLOYMENT_CHANGES=true (changes detected)"
        echo ""
        printf "Do you want to continue with the deployment? (y/n): "
        read -r confirmation
        echo ""
        
        if [ "$confirmation" != "y" ] && [ "$confirmation" != "Y" ]; then
            log "INFO" "Deployment cancelled by user"
            exit 0
        fi
        
        log "INFO" "User confirmed deployment - proceeding..."
    else
        DEMO_HAS_DEPLOYMENT_CHANGES=false
        log "DEBUG" "Set DEMO_HAS_DEPLOYMENT_CHANGES=false (no changes needed)"
        log "INFO" "No significant changes detected - proceeding with deployment"
    fi
fi

# Cache VNET information to be saved after successful deployment
if is_local_run; then
    # Just log the VNET info, but don't save it to S3 yet
    log "INFO" "VNET information cached for later use after successful deployment"
else
    log "INFO" "VNET information cached for later use after successful deployment"
fi

###################################################################################
# Regenerate Bytecode
###################################################################################

# Always use locked bytecode for deploy_v2_vnet_s3 script - never regenerate
log "INFO" "Using locked bytecode from script/locked-bytecode/ for all branches"
log "INFO" "Skipping bytecode regeneration to ensure consistency"

###################################################################################
# Contract Deployment
###################################################################################

# Set up verifier URLs
ETH_MAINNET_VERIFIER_URL="$ETH_MAINNET/verify/etherscan"
BASE_MAINNET_VERIFIER_URL="$BASE_MAINNET/verify/etherscan"
OPTIMISM_MAINNET_VERIFIER_URL="$OPTIMISM_MAINNET/verify/etherscan"

# Set initial balances
log "INFO" "Setting initial balances..."
set_initial_balance "$ETH_MAINNET"
set_initial_balance "$BASE_MAINNET"
set_initial_balance "$OPTIMISM_MAINNET"

# Function to handle deployment failures without updating S3 files
deploy_error_handler() {
    local network=$1
    log "ERROR" "Failed to deploy V2 on $network"
    log "INFO" "No S3 files were updated since deployment failed"
    exit 1
}

# Set trap to ensure S3 files are preserved on any unexpected error
trap 'log "ERROR" "Unexpected error occurred, preserving S3 file"; exit 1' ERR

# Deploy all networks - Core contracts only
deploy_contracts() {
    # Deploy Core contracts on Ethereum Mainnet
    log "INFO" "Deploying V2 Core on Ethereum Mainnet..."
    if ! forge script script/DeployV2Core.s.sol:DeployV2Core \
        --sig 'run(uint256,uint64,string)' $FORGE_ENV $ETH_CHAIN_ID "$ETH_SALT" \
        --verify \
        --verifier-url $ETH_MAINNET_VERIFIER_URL \
        --rpc-url $ETH_MAINNET \
        --etherscan-api-key $TENDERLY_ACCESS_KEY \
        --broadcast \
        --jobs 10 \
        -vvv \
        --slow; then
        deploy_error_handler "Ethereum"
    fi
    wait
    
    # Deploy Core contracts on Base Mainnet
    log "INFO" "Deploying V2 Core on Base Mainnet..."
    if ! forge script script/DeployV2Core.s.sol:DeployV2Core \
        --sig 'run(uint256,uint64,string)' $FORGE_ENV $BASE_CHAIN_ID "$BASE_SALT" \
        --verify \
        --verifier-url $BASE_MAINNET_VERIFIER_URL \
        --rpc-url $BASE_MAINNET \
        --etherscan-api-key $TENDERLY_ACCESS_KEY \
        --broadcast \
        --jobs 10 \
        -vvv \
        --slow; then
        deploy_error_handler "Base"
    fi
    wait
    
    # Deploy Core contracts on Optimism Mainnet
    log "INFO" "Deploying V2 Core on Optimism Mainnet..."
    if ! forge script script/DeployV2Core.s.sol:DeployV2Core \
        --sig 'run(uint256,uint64,string)' $FORGE_ENV $OPTIMISM_CHAIN_ID "$OPTIMISM_SALT" \
        --verify \
        --verifier-url $OPTIMISM_MAINNET_VERIFIER_URL \
        --rpc-url $OPTIMISM_MAINNET \
        --etherscan-api-key $TENDERLY_ACCESS_KEY \
        --broadcast \
        --jobs 10 \
        -vvv \
        --slow; then
        deploy_error_handler "Optimism"
    fi
    wait
    
    # If we reach here, all core deployments were successful
    log "INFO" "All V2 Core deployments completed successfully!"
    return 0
}



# Update the branch latest file section to use validation
update_latest_file() {
    log "INFO" "All deployments successful. Updating latest file..."
    
    # Initialize content with default structure
    content="{\"networks\":{},\"updated_at\":null}"
    local latest_file
    local initial_sha=""
    
    # Always use S3 for file operations
    latest_file_path="/tmp/update_latest_file_$$.json"

    # Download latest.json from S3
    if aws s3 cp "s3://$S3_BUCKET_NAME/$GITHUB_REF_NAME/latest.json" "$latest_file_path" --quiet; then
        log "INFO" "Successfully downloaded latest.json from S3"
        log "DEBUG" "Downloaded file size: $(wc -c < "$latest_file_path") bytes"

        # Read the file and validate JSON
        content=$(cat "$latest_file_path")
        log "DEBUG" "Content length after reading: ${#content} characters"

        # Validate the content from file
        if ! echo "$content" | jq '.' >/dev/null 2>&1; then
            log "WARN" "Invalid JSON in latest file, resetting to default"
            content="{\"networks\":{},\"updated_at\":null}"
        else
            log "DEBUG" "JSON validation successful"
        fi
    else
        log "WARN" "latest.json not found in S3, initializing empty file"
        content="{\"networks\":{},\"updated_at\":null}"
    fi
    
    log "DEBUG" "Initial content structure:"
    echo "$content" | jq '.' >&2
    
    # Collect all network contracts first
    declare -A ALL_NETWORK_CONTRACTS
    declare -A ALL_NETWORK_VNET_IDS
    declare -A ALL_NETWORK_SALTS
    
    # Read all network deployment files
    i=0
    for network in 1 8453 10; do
        network_slug=$(get_network_slug "$network")
        vnet_id=$(echo "${VNET_RESPONSES[$i]}" | cut -d'|' -f2)
        
        # Read and validate deployed contracts
        local network_dir="$OUTPUT_BASE_DIR/$GITHUB_REF_NAME/$network"
        contracts_file="$network_dir/$network_slug-latest.json"
        
        log "INFO" "Reading contracts from: $contracts_file"
        
        if [ ! -f "$contracts_file" ]; then
            log "ERROR" "Contract file not found for $network_slug: $contracts_file"
            exit 1
        fi
        
        # Read contracts file and ensure it's valid JSON
        contracts=$(tr -d '\r' < "$contracts_file")
        if ! contracts=$(echo "$contracts" | jq -c '.' 2>/dev/null); then
            log "ERROR" "Failed to parse JSON from contract file for $network_slug"
            exit 1
        fi
        
        # Add mock contracts for demo branch
        if [ "$BRANCH_NAME" = "demo" ]; then
            contracts=$(echo "$contracts" | jq '. + {
                "MockDex": "0x4A0933f951A9768ce9AC2F272e459090a2De4c32",
                "MockDexHook": "0x8455e14eFF2592303c13D31af23028992b07217B"
            }')
        fi
        
        # Store in associative arrays
        ALL_NETWORK_CONTRACTS["$network_slug"]="$contracts"
        ALL_NETWORK_VNET_IDS["$network_slug"]="$vnet_id"
        
        # Store salt
        case "$network" in
            1)
                ALL_NETWORK_SALTS["$network_slug"]="$ETH_SALT"
                ;;
            8453)
                ALL_NETWORK_SALTS["$network_slug"]="$BASE_SALT"
                ;;
            10)
                ALL_NETWORK_SALTS["$network_slug"]="$OPTIMISM_SALT"
                ;;
        esac
        
        i=$((i + 1))
    done
    
    
    # Update content with all network deployment info at once
    for network_slug in "Ethereum" "Base" "Optimism"; do
        content=$(echo "$content" | jq \
            --arg slug "$network_slug" \
            --arg vnet "${ALL_NETWORK_VNET_IDS[$network_slug]}" \
            --arg counter "${ALL_NETWORK_SALTS[$network_slug]}" \
            --argjson contracts "${ALL_NETWORK_CONTRACTS[$network_slug]}" \
            '.networks[$slug] = {
                "counter": ($counter|tonumber),
                "vnet_id": $vnet,
                "contracts": $contracts
            }')
    done
    
    # Update timestamp
    content=$(echo "$content" | jq --arg time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" '.updated_at = $time')
    
    # Always use S3 for file operations
    # Format JSON nicely
    content=$(echo "$content" | jq '.')
    
        # Use -w 0 to avoid line wrapping in base64 output
        encoded_content=$(echo -n "$content" | base64 -w 0)
        
        update_data="{\"message\":\"Update branch latest file\",\"content\":\"$encoded_content\""
        
        # Only include SHA if we have one (for existing files)
        if [ -n "$initial_sha" ]; then
            log "INFO" "Including SHA in update request: $initial_sha"
            update_data="$update_data,\"sha\":\"$initial_sha\""
        fi
        
        update_data="$update_data,\"branch\":\"$GITHUB_REF_NAME\"}"
        
    echo "$content" | jq '.' > "$latest_file_path"
    
    # Demo branch special handling - show diff and prompt for upload
    if [ "$IS_DEMO_BRANCH" = true ] && [ "$REDEPLOY_FLAG" != "redeploy" ]; then
        log "DEBUG" "Demo branch S3 check: DEMO_HAS_DEPLOYMENT_CHANGES=$DEMO_HAS_DEPLOYMENT_CHANGES"
        # If there were no deployment changes needed, skip S3 upload entirely
        if [ "$DEMO_HAS_DEPLOYMENT_CHANGES" = false ]; then
            log "INFO" "No deployment changes were needed - skipping S3 upload (contracts already up to date)"
            return 0
        fi
        
        log "INFO" "Demo branch detected - showing contract differences before S3 upload"
        
        # Download existing S3 content for comparison
        local existing_s3_content="{\"networks\":{}}"
        local existing_s3_path="/tmp/existing_latest_$$.json"
        if aws s3 cp "s3://$S3_BUCKET_NAME/$GITHUB_REF_NAME/latest.json" "$existing_s3_path" --quiet 2>/dev/null; then
            existing_s3_content=$(cat "$existing_s3_path")
            if ! echo "$existing_s3_content" | jq '.' >/dev/null 2>&1; then
                existing_s3_content="{\"networks\":{}}"
            fi
        fi
        
        # Show diff and check if there are changes
        if show_demo_s3_diff "$existing_s3_content"; then
            # There are changes - prompt user for confirmation
            echo ""
            printf "Do you want to upload these changes to S3? (y/n): "
            read -r upload_confirmation
            echo ""
            
            if [ "$upload_confirmation" != "y" ] && [ "$upload_confirmation" != "Y" ]; then
                log "INFO" "S3 upload cancelled by user - contracts deployed but S3 not updated"
                return 0
            fi
            
            log "INFO" "User confirmed S3 upload - proceeding..."
        else
            # No changes detected - skip upload automatically
            log "INFO" "No contract changes detected - skipping S3 upload (contracts already up to date)"
            return 0
        fi
    fi
    
    # Upload to S3
    if aws s3 cp "$latest_file_path" "s3://$S3_BUCKET_NAME/$GITHUB_REF_NAME/latest.json" --quiet; then
        log "SUCCESS" "Successfully uploaded latest.json to S3"
    else
        log "ERROR" "Failed to upload latest.json to S3"
        exit 1
    fi
}

# Run all deployments and update the latest file only if successful
# Run the deployment process
deploy_contracts

# If we get here, all deployments were successful
# First ensure we have VNET info saved properly (this was delayed until after successful deployment)
if is_local_run; then
    save_vnet_info true
else
    save_vnet_info false
fi

# Now update the latest file with the new contract addresses
# Since we're using S3 for everything now, no need to pass parameters
update_latest_file

###################################################################################
# SuperLedger Configuration (separate from main deployment)
###################################################################################

# Only run SuperLedger configuration if not demo branch OR if demo branch with redeploy flag
if [ "$BRANCH_NAME" != "demo" ] || ([ "$BRANCH_NAME" = "demo" ] && [ "$REDEPLOY_FLAG" = "redeploy" ]); then
    log "INFO" "Running SuperLedger configurations separately..."
    
    # Configure SuperLedger for each network
    i=0
    for network in 1 8453 10; do
        network_slug=$(get_network_slug "$network")
        admin_rpc=$(echo "${VNET_RESPONSES[$i]}" | cut -d'|' -f1)
        
        # Get the salt for this network
        case "$network" in
            1)
                salt="$ETH_SALT"
                ;;
            8453)
                salt="$BASE_SALT"
                ;;
            10)
                salt="$OPTIMISM_SALT"
                ;;
        esac
        
        log "INFO" "Configuring SuperLedger on $network_slug..."
        if ! forge script script/DeployV2Core.s.sol:DeployV2Core \
            --sig 'runLedgerConfigurations(uint256,uint64,string,string)' $FORGE_ENV $network "$salt" "$BRANCH_NAME" \
            --rpc-url "$admin_rpc" \
            --chain $network \
            --broadcast \
            -vv \
            --slow; then
            log "ERROR" "Failed to configure SuperLedger on $network_slug"
            exit 1
        fi
        wait
        
        i=$((i + 1))
    done
    
    log "SUCCESS" "All SuperLedger configurations completed successfully!"
else
    log "INFO" "Skipping SuperLedger configuration for demo branch with fixed salt"
fi

log "SUCCESS" "All V2 Core deployments completed successfully!"